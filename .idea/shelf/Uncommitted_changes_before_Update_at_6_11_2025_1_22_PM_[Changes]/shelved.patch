Index: multiagent/ghostAgents.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># ghostAgents.py\r\n# --------------\r\n# Licensing Information:  You are free to use or extend these projects for\r\n# educational purposes provided that (1) you do not distribute or publish\r\n# solutions, (2) you retain this notice, and (3) you provide clear\r\n# attribution to UC Berkeley, including a link to http://ai.berkeley.edu.\r\n#\r\n# Attribution Information: The Pacman AI projects were developed at UC Berkeley.\r\n# The core projects and autograders were primarily created by John DeNero\r\n# (denero@cs.berkeley.edu) and Dan Klein (klein@cs.berkeley.edu).\r\n# Student side autograding was added by Brad Miller, Nick Hay, and\r\n# Pieter Abbeel (pabbeel@cs.berkeley.edu).\r\n\r\nfrom game import Agent\r\nfrom game import Actions\r\nfrom game import Directions\r\nimport random\r\nfrom util import manhattanDistance\r\nimport util\r\nimport heapq\r\nfrom pacman import GameState\r\nfrom math import ceil, floor\r\n\r\n\r\nclass GhostAgent(Agent):\r\n    def __init__(self, index):\r\n        self.index = index\r\n\r\n    def getAction(self, state):\r\n        dist = self.getDistribution(state)\r\n        if len(dist) == 0:\r\n            return Directions.STOP\r\n        else:\r\n            return util.chooseFromDistribution(dist)\r\n\r\n    def getDistribution(self, state):\r\n        \"Returns a Counter encoding a distribution over actions from the provided state.\"\r\n        util.raiseNotDefined()\r\n\r\n    def a_star_search(self, state, goal):\r\n        open_set = []\r\n        path = []\r\n        visited = set()\r\n        start = state.getGhostPosition(self.index)\r\n        heapq.heappush(open_set, (self.heuristic(start, goal), 0, []))\r\n        legalStartDirections = [Actions.directionToVector(a) for a in state.getLegalActions(self.index)]\r\n        while open_set:\r\n            f, g, path = heapq.heappop(open_set)\r\n            current = path[-1] if path else start\r\n            if current == goal:\r\n                return path\r\n            \r\n            if current in visited:\r\n                continue\r\n            visited.add(current)\r\n\r\n            directions = [(-1,0), (1,0), (0,-1), (0,1)]\r\n            for d in directions:\r\n                if d not in legalStartDirections and current == start:\r\n                    continue\r\n                nx, ny = self.nextIntPosition(current, d)\r\n                nx, ny = int(nx), int(ny)\r\n                if self.checkValidPosition(state, (nx, ny)):\r\n                    next_node = (nx, ny)\r\n                    if next_node not in visited:\r\n                        heapq.heappush(open_set, (\r\n                            g + 1 + self.heuristic(next_node, goal),\r\n                            g + 1,\r\n                            path + [next_node]\r\n                        ))\r\n        return []\r\n\r\n\r\n    def nextIntPosition(self, pos, direction):\r\n        if direction == (0, -1):\r\n            return pos[0], ceil(pos[1] - 1)  # South\r\n        elif direction == (0, 1):\r\n            return pos[0], floor(pos[1] + 1)  # North\r\n        elif direction == (-1, 0):\r\n            return ceil(pos[0] - 1), pos[1]\r\n        elif direction == (1, 0):\r\n            return floor(pos[0] + 1), pos[1]\r\n\r\n    def checkValidPosition(self, state, pos):\r\n        walls = state.getWalls()\r\n        nx = int(pos[0])\r\n        ny = int(pos[1])\r\n        cols, rows = walls.width, walls.height\r\n        if 0 < nx < cols and 0 < ny < rows and not walls[nx][ny]:\r\n            return True\r\n        return False\r\n\r\nclass RandomGhost(GhostAgent): # Kế thừa từ GhostAgent\r\n    \"A ghost that chooses a legal action uniformly at random.\"\r\n    def __init__(self, index):\r\n        self.index = index\r\n\r\n    def getDistribution(self, state):\r\n        dist = util.Counter()\r\n        for a in state.getLegalActions(self.index):\r\n            dist[a] = 1.0\r\n        dist.normalize()\r\n        return dist\r\n\r\n\r\nclass DirectionalGhost(GhostAgent):\r\n    \"A ghost that prefers to rush Pacman, or flee when scared.\"\r\n\r\n    def __init__(self, index, prob_attack=0.7, prob_scaredFlee=0.5):\r\n        self.index = index\r\n        self.prob_attack = prob_attack\r\n        self.prob_scaredFlee = prob_scaredFlee\r\n\r\n    def getDistribution(self, state):\r\n        # Read variables from state\r\n        ghostState = state.getGhostState(self.index)\r\n        legalActions = state.getLegalActions(self.index)\r\n        pos = state.getGhostPosition(self.index)\r\n        isScared = ghostState.scaredTimer > 0\r\n\r\n        speed = 1\r\n        if isScared:\r\n            speed = 0.5\r\n\r\n        actionVectors = [Actions.directionToVector(\r\n            a, speed) for a in legalActions]\r\n\r\n        newPositions = [(pos[0]+a[0], pos[1]+a[1]) for a in actionVectors]\r\n        pacmanPosition = state.getPacmanPosition()\r\n\r\n        # Select best actions given the state\r\n        distancesToPacman = [manhattanDistance(pos, pacmanPosition) for pos in newPositions]\r\n        if isScared:\r\n            bestScore = max(distancesToPacman)\r\n            bestProb = self.prob_scaredFlee\r\n        else:\r\n            bestScore = min(distancesToPacman)\r\n            bestProb = self.prob_attack\r\n        bestActions = [action for action, distance in zip(\r\n            legalActions, distancesToPacman) if distance == bestScore]\r\n\r\n        # Construct distribution\r\n        dist = util.Counter()\r\n        for a in bestActions:\r\n            dist[a] = bestProb / len(bestActions)\r\n        for a in legalActions:\r\n            dist[a] += (1-bestProb) / len(legalActions)\r\n        dist.normalize()\r\n        return dist\r\n    \r\nclass AStarGhost(GhostAgent):\r\n    \"A ghost that prefers to rush Pacman, or flee when scared, with a higher probability.\"\r\n\r\n    def __init__(self, index, prob_attack=1, prob_scaredFlee=1):\r\n        self.index = index\r\n        self.prob_attack = prob_attack\r\n        self.prob_scaredFlee = prob_scaredFlee\r\n\r\n    def heuristic(self, a, b):\r\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\r\n    \r\n    def getDistribution(self, state):\r\n        ghostState = state.getGhostState(self.index)\r\n        legalActions = state.getLegalActions(self.index)\r\n        isScared = ghostState.scaredTimer > 0\r\n        pacmanPosition = state.getPacmanPosition()\r\n        pos = state.getGhostPosition(self.index)\r\n\r\n        conf = ghostState.configuration\r\n        reverse = Actions.reverseDirection(conf.direction)\r\n        reverse = Actions.directionToVector(reverse)\r\n        \r\n\r\n        # Sử dụng thuật toán A* để tìm đường đi đến Pacman\r\n        searchPath = self.a_star_search(state, pacmanPosition)\r\n        bestAction = (searchPath[0][0] - pos[0], searchPath[0][1] - pos[1])  if searchPath else Directions.STOP\r\n        bestAction = Actions.vectorToDirection(bestAction)\r\n\r\n        # Construct distribution\r\n        dist = util.Counter()\r\n        if isScared:\r\n            if (len(legalActions) == 1):\r\n                dist[bestAction] = 1\r\n            else:\r\n                for a in legalActions:\r\n                    if a != bestAction:\r\n                        dist[a] = 1/(len(legalActions) - 1)\r\n        else:\r\n            dist[bestAction] = 1\r\n\r\n        if bestAction not in legalActions:\r\n            input()\r\n            \r\n        return dist\r\n\r\n    \r\nclass BlockingGhost(GhostAgent):\r\n    \"A ghost that prefers to rush Pacman, or flee when scared, with a higher probability.\"\r\n\r\n    def __init__(self, index, prob_attack=1, prob_scaredFlee=1):\r\n        self.index = index\r\n        self.prob_attack = prob_attack\r\n        self.prob_scaredFlee = prob_scaredFlee\r\n\r\n    def heuristic(self, a, b):\r\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\r\n    \r\n    \r\n    def predictPacmanPosition(self, state : GameState, step=5):\r\n        pos = state.getPacmanPosition()\r\n        successor = state\r\n\r\n        for _ in range(step):\r\n            pacmanLLegalActions = successor.getLegalActions(0)\r\n            if Directions.STOP in pacmanLLegalActions:\r\n                pacmanLLegalActions.remove(Directions.STOP)\r\n            reverse = Actions.reverseDirection(successor.getPacmanState().configuration.direction)\r\n            if reverse in pacmanLLegalActions:               # Nếu Pacman có thể đi ngược lại hướng đang đi\r\n                pacmanLLegalActions.remove(reverse)          # Loại bỏ hành động đi ngược lại hướng đang đi, do có một con ma dí đuôi r\r\n\r\n            if len(pacmanLLegalActions) == 1:                           # Nếu Pacman có thể tiếp tục đi hướng đang đi\r\n                successor = successor.generateSuccessor(0, pacmanLLegalActions[0])\r\n                pos = successor.getPacmanPosition()\r\n                continue\r\n            else:\r\n                if len(pacmanLLegalActions) == 0:\r\n                    break\r\n                else:                                                   # Nếu Pacman có nhiều hành động hợp lệ\r\n                    scores = self.scoreForPacmanAction(successor, pacmanLLegalActions)\r\n                    best_score = max(scores) if scores else 0\r\n                    best_actions = [action for action, score in zip(pacmanLLegalActions, scores) if score == best_score]\r\n                    #pacmanDirection = successor.getPacmanState().configuration.direction\r\n                    #if pacmanDirection in best_actions:  # Nếu Pacman có thể tiếp tục đi hướng đang đi\r\n                        ##continue\r\n                    best_action = random.choice(best_actions)\r\n\r\n                successor = successor.generateSuccessor(0, best_action)\r\n                pos = successor.getPacmanPosition()\r\n        return pos\r\n\r\n    def scoreForPacmanAction(self, state : GameState, actions):\r\n        pacmanPos = state.getPacmanPosition()\r\n        ghostPos = state.getGhostPositions()\r\n        nextPacmanPos = [Actions.getSuccessor(pacmanPos, action) for action in actions]\r\n\r\n        # Tính khoảng cách từ vị trí của Pacman sau khi thực hiện action đến vị trí của capsule\r\n        distanceToCapsules = [[manhattanDistance(nextPacmanPos, capsule) for capsule in state.getCapsules()] for nextPacmanPos in nextPacmanPos]\r\n        capsuleScore = [min(distanceToCapsules[i]) if len(distanceToCapsules[i]) > 0 else 0 for i in range(len(nextPacmanPos))]\r\n        \r\n        # Tính khoảng cách từ vị trí của Pacman sau khi thực hiện action đến vị trí của ghost\r\n        distanceToGhosts = [[manhattanDistance(nextPacmanPos, ghost) for ghost in ghostPos] for nextPacmanPos in nextPacmanPos]\r\n        ghostScore = [sum(distanceToGhosts[i]) / len(distanceToGhosts[i]) if len(distanceToGhosts[i]) > 0 else 0 for i in range(len(nextPacmanPos))]\r\n\r\n        # Tính khoảng cách đến vị trí của food\r\n        foodPositions = state.getFood().asList()\r\n        distanceToFood = [[manhattanDistance(nextPacmanPos, food) for food in foodPositions] for nextPacmanPos in nextPacmanPos]\r\n        foodScore = [sum(distanceToFood[i]) / len(distanceToFood[i]) if len(distanceToFood[i]) > 0 else 0 for i in range(len(nextPacmanPos))]\r\n\r\n        # Sum score\r\n        scores = [1 / (capsuleScore[i] + 0.1) * 2 \r\n                  - 1 / (ghostScore[i] + 0.1) \r\n                  + 1 / (foodScore[i] + 0.1)\r\n                for i in range(len(nextPacmanPos))]\r\n        return scores\r\n\r\n    \r\n    def blockPacmanRoute(self, state, max_prediction_steps=10):\r\n        \"\"\"\r\n        Tìm đường đi ngắn nhất đến một vị trí PACMAN có thể đến mà ma có thể đến trước/ cùng lúc với PACMAN để chặn PACMAN di chuyển đến đó.\r\n        Trả về đường đi dưới dạng một danh sách các tọa độ (x, y) mà ma có thể đi đến.\r\n        Nếu không tìm thấy đường đi nào, trả về một danh sách rỗng.\r\n        \"\"\"\r\n        path = self.a_star_search(state, state.getPacmanPosition())\r\n        first_step = path[0] if path else None\r\n        if len(path) == 1:\r\n            return path\r\n        pacmanStep = 0\r\n        while len(path) > pacmanStep and pacmanStep < max_prediction_steps:\r\n            pacmanStep += 1\r\n            nextPacmanPosition = self.predictPacmanPosition(state, step=pacmanStep)\r\n            path = self.a_star_search(state, nextPacmanPosition)\r\n        return path if path else [first_step]               # Khi vị trí PACMAN dự định tới trùng với vị trí của ma, trả về đường đi từ vị trí hiện tại của ma đến vị trí PACMAN hiện tại.\r\n    \r\n    def getDistribution(self, state):\r\n        ghostState = state.getGhostState(self.index)\r\n        legalActions = state.getLegalActions(self.index)\r\n        isScared = ghostState.scaredTimer > 0\r\n        pacmanPosition = state.getPacmanPosition()\r\n        pos = state.getGhostPosition(self.index)\r\n\r\n\r\n        conf = ghostState.configuration\r\n        reverse = Actions.reverseDirection(conf.direction)\r\n        reverse = Actions.directionToVector(reverse)\r\n        \r\n        speed = 1\r\n        if isScared:\r\n            speed = 0.5\r\n\r\n        # Tìm cách chặn Pacman\r\n        searchPath = self.blockPacmanRoute(state)\r\n        bestAction = (searchPath[0][0] - pos[0], searchPath[0][1] - pos[1])  if searchPath else Directions.STOP\r\n        bestAction = Actions.vectorToDirection(bestAction)\r\n\r\n        # Construct distribution\r\n        dist = util.Counter()\r\n        if isScared:\r\n            if (len(legalActions) == 1):\r\n                dist[bestAction] = 1\r\n            else:\r\n                for a in legalActions:\r\n                    if a != bestAction:\r\n                        dist[a] = 1/(len(legalActions) - 1)\r\n\r\n        else:\r\n            dist[bestAction] = 1\r\n\r\n        if bestAction not in legalActions:\r\n            input()\r\n            \r\n        return dist\r\n\r\n#----------------------------------------------------------------------------------------------------------------------------\r\nclass MinimaxGhost(GhostAgent):\r\n    \"\"\"\r\n    Ghost dùng thuật toán minimax.\r\n    Ghost sẽ chọn hành động sao cho khi tính đến các lượt đi:\r\n        - Pac-Man (agent 0) là MAX: tìm cách tăng giá trị đánh giá (trạng thái tốt cho Pac-Man).\r\n        - Các ghost (bao gồm ghost này) là MIN: tìm cách giảm giá trị đánh giá (trạng thái xấu cho Pac-Man).\r\n    Chúng ta giả sử hàm đánh giá (evaluationFunction) được thiết kế phù hợp với mục tiêu của ghost.\r\n    \"\"\"\r\n\r\n    def __init__(self, index, depth=3, evaluationFunction=None):\r\n        self.index = index\r\n        self.depth = depth\r\n        if evaluationFunction is None:\r\n            self.evaluationFunction = self.defaultEvaluationFunction\r\n        else:\r\n            self.evaluationFunction = evaluationFunction\r\n\r\n    def defaultEvaluationFunction(self, state):\r\n        pacmanPos = state.getPacmanPosition()\r\n        ghostPos = state.getGhostPosition(self.index)\r\n        ghosts = [state.getGhostPosition(i) for i in range(1, state.getNumAgents())]\r\n        foodList = state.getFood().asList()\r\n        capsules = state.getCapsules()\r\n        numFood = len(foodList)\r\n        numCapsule = len(capsules)\r\n\r\n        score = 0\r\n\r\n        distToSpawn = util.manhattanDistance(ghostPos, (9,5))\r\n        if distToSpawn <= 1:\r\n            score += 200\r\n\r\n        ghostState = state.getGhostState(self.index)\r\n        distToPacman = util.manhattanDistance(ghostPos, pacmanPos)\r\n        isScared = ghostState.scaredTimer > 0\r\n\r\n        if isScared:\r\n            if distToPacman <= 1:\r\n                score += 100000\r\n            score -= 1000 / (distToPacman + 1)\r\n        else:\r\n            score -= 1000 / (distToPacman + 1)\r\n\r\n            if foodList:\r\n                minFoodDist = min(util.manhattanDistance(pacmanPos, food) for food in foodList)\r\n                score -= 5.0 / (minFoodDist + 1)\r\n            if capsules:\r\n                minCapDist = min(util.manhattanDistance(pacmanPos, cap) for cap in capsules)\r\n                score -= 5.0 / (minCapDist + 1)\r\n\r\n            walls = state.getWalls()\r\n            adjacent = 0\r\n            x, y = pacmanPos\r\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\r\n                if walls[x + dx][y + dy]:\r\n                    adjacent += 1\r\n            if adjacent >= 2:\r\n                score -= 40\r\n\r\n            numGhostsNear = sum(\r\n                1 for i, gpos in enumerate(ghosts)\r\n                if i + 1 != self.index and util.manhattanDistance(gpos, pacmanPos) <= 2\r\n            )\r\n            score -= 50 * numGhostsNear\r\n\r\n            if state.isWin():\r\n                score += 10000\r\n            if state.isLose():\r\n                score -= 10000\r\n\r\n        print(score, isScared, ghostPos)\r\n        return score\r\n\r\n    def getAction(self, state):\r\n        \"\"\"\r\n        Phương thức này sẽ duyệt qua các hành động hợp lệ của ghost hiện hành\r\n        và chọn hành động mà cho kết quả minimax là nhỏ nhất, theo mục tiêu của ghost.\r\n        \"\"\"\r\n        legalActions = state.getLegalActions(self.index)\r\n        if not legalActions:\r\n            return Directions.STOP\r\n\r\n        bestScore = float(\"inf\")\r\n        bestAction = None\r\n        # Ở gốc (depth = 0) ta duyệt qua các nước đi của ghost này\r\n        for action in legalActions:\r\n            successor = state.generateSuccessor(self.index, action)\r\n            score = self.minimax(successor, self.getNextAgent(state, self.index), 0)\r\n            if score < bestScore:\r\n                bestScore = score\r\n                bestAction = action\r\n        if bestAction is None:\r\n            return Directions.STOP\r\n        return bestAction\r\n\r\n    def minimax(self, state, agentIndex, depthSoFar):\r\n        \"\"\"\r\n        Hàm minimax đa tác nhân:\r\n          - Pac-Man (agent 0) là MAX.\r\n          - Các ghost (agent != 0) là MIN.\r\n        Lưu ý: Một \"ply\" được định nghĩa là 1 lượt của Pac-Man và tất cả ghost.\r\n        \"\"\"\r\n        # Điều kiện dừng: nếu game kết thúc hoặc đạt giới hạn độ sâu\r\n        if state.isWin() or state.isLose() or depthSoFar == self.depth:\r\n            return self.evaluationFunction(state)\r\n\r\n        numAgents = state.getNumAgents()\r\n        nextAgent = self.getNextAgent(state, agentIndex)\r\n        nextDepth = depthSoFar + 1 if nextAgent == 0 else depthSoFar\r\n\r\n        legalActions = state.getLegalActions(agentIndex)\r\n        if not legalActions:\r\n            return self.evaluationFunction(state)\r\n\r\n        # Nếu là lượt của Pac-Man (agent 0): MAX node\r\n        if agentIndex == 0:\r\n            value = float(\"-inf\")\r\n            for action in legalActions:\r\n                successor = state.generateSuccessor(agentIndex, action)\r\n                value = max(value, self.minimax(successor, nextAgent, nextDepth))\r\n            return value\r\n        else:\r\n            # Là lượt của ghost (các tác nhân khác bao gồm cả ghost hiện hành): MIN node\r\n            value = float(\"inf\")\r\n            for action in legalActions:\r\n                successor = state.generateSuccessor(agentIndex, action)\r\n                value = min(value, self.minimax(successor, nextAgent, nextDepth))\r\n            return value\r\n\r\n    def getNextAgent(self, state, currentAgent):\r\n        numAgents = state.getNumAgents()\r\n        return (currentAgent + 1) % numAgents\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/multiagent/ghostAgents.py b/multiagent/ghostAgents.py
--- a/multiagent/ghostAgents.py	(revision c8b45e353c6238e835b605e70e8a249937c113f0)
+++ b/multiagent/ghostAgents.py	(date 1749622637929)
@@ -330,7 +330,7 @@
     Chúng ta giả sử hàm đánh giá (evaluationFunction) được thiết kế phù hợp với mục tiêu của ghost.
     """
 
-    def __init__(self, index, depth=3, evaluationFunction=None):
+    def __init__(self, index, depth=1, evaluationFunction=None):
         self.index = index
         self.depth = depth
         if evaluationFunction is None:
@@ -351,25 +351,25 @@
 
         distToSpawn = util.manhattanDistance(ghostPos, (9,5))
         if distToSpawn <= 1:
-            score += 200
+            score += 5000
 
         ghostState = state.getGhostState(self.index)
         distToPacman = util.manhattanDistance(ghostPos, pacmanPos)
         isScared = ghostState.scaredTimer > 0
 
         if isScared:
-            if distToPacman <= 1:
-                score += 100000
+            if distToPacman <= 2:
+                score += 10000
             score -= 1000 / (distToPacman + 1)
         else:
             score -= 1000 / (distToPacman + 1)
 
             if foodList:
                 minFoodDist = min(util.manhattanDistance(pacmanPos, food) for food in foodList)
-                score -= 5.0 / (minFoodDist + 1)
+                score -= 1000 / (minFoodDist + 1)
             if capsules:
                 minCapDist = min(util.manhattanDistance(pacmanPos, cap) for cap in capsules)
-                score -= 5.0 / (minCapDist + 1)
+                score -= 1000 / (minCapDist + 1)
 
             walls = state.getWalls()
             adjacent = 0
@@ -384,7 +384,7 @@
                 1 for i, gpos in enumerate(ghosts)
                 if i + 1 != self.index and util.manhattanDistance(gpos, pacmanPos) <= 2
             )
-            score -= 50 * numGhostsNear
+            score -= 200 * numGhostsNear
 
             if state.isWin():
                 score += 10000
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"b14f4dbb-6c9e-4991-ad6e-6afb3026a58a\" name=\"Changes\" comment=\"&#10;.\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/AI_Pacman.iml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/AI_Pacman.iml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/multiagent/ghostAgents.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/multiagent/ghostAgents.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;Khoi20225869&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\"><![CDATA[{\r\n  \"selectedUrlAndAccountId\": {\r\n    \"url\": \"https://github.com/manhnd52/AI_Pacman.git\",\r\n    \"accountId\": \"ddbacb7e-7470-48b0-bb2a-bef2d5d78a9d\"\r\n  }\r\n}]]></component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 7\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2y2GNPn0TYxpWJA7DV0lf9EXA5h\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"ModuleVcsDetector.initialDetectionPerformed\": \"true\",\r\n    \"Python.game.executor\": \"Run\",\r\n    \"Python.keyboardAgents.executor\": \"Run\",\r\n    \"Python.layout.executor\": \"Run\",\r\n    \"Python.main.executor\": \"Debug\",\r\n    \"Python.multiAgents.executor\": \"Run\",\r\n    \"Python.pacman.executor\": \"Run\",\r\n    \"Python.pacmanAgents.executor\": \"Run\",\r\n    \"Python.projectParams.executor\": \"Run\",\r\n    \"Python.testClasses.executor\": \"Run\",\r\n    \"Python.tạm.executor\": \"Run\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"RunOnceActivity.git.unshallow\": \"true\",\r\n    \"git-widget-placeholder\": \"main\",\r\n    \"ignore.virus.scanning.warn.message\": \"true\",\r\n    \"last_opened_file_path\": \"D:/Hoc/AI/AI_Pacman\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"settings.editor.selected.configurable\": \"com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\" selected=\"Python.game\">\r\n    <configuration name=\"game\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AI_Pacman\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/multiagent\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/multiagent/game.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AI_Pacman\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/multiagent/A_search\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/multiagent/A_search/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"multiAgents\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AI_Pacman\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/multiagent\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/multiagent/multiAgents.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"pacmanAgents\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AI_Pacman\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/multiagent\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/multiagent/pacmanAgents.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"testClasses\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AI_Pacman\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/multiagent\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/multiagent/testClasses.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.game\" />\r\n        <item itemvalue=\"Python.multiAgents\" />\r\n        <item itemvalue=\"Python.pacmanAgents\" />\r\n        <item itemvalue=\"Python.testClasses\" />\r\n        <item itemvalue=\"Python.main\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-js-predefined-d6986cc7102b-6a121458b545-JavaScript-PY-251.25410.159\" />\r\n        <option value=\"bundled-python-sdk-e0ed3721d81e-36ea0e71a18c-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-251.25410.159\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"b14f4dbb-6c9e-4991-ad6e-6afb3026a58a\" name=\"Changes\" comment=\"\" />\r\n      <created>1749025216615</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1749025216615</updated>\r\n      <workItem from=\"1749025217989\" duration=\"62000\" />\r\n      <workItem from=\"1749025356633\" duration=\"257000\" />\r\n      <workItem from=\"1749025797801\" duration=\"189000\" />\r\n      <workItem from=\"1749291373721\" duration=\"257000\" />\r\n      <workItem from=\"1749291649204\" duration=\"55000\" />\r\n      <workItem from=\"1749291864409\" duration=\"640000\" />\r\n      <workItem from=\"1749303477398\" duration=\"345000\" />\r\n      <workItem from=\"1749304146195\" duration=\"337000\" />\r\n      <workItem from=\"1749304527955\" duration=\"608000\" />\r\n      <workItem from=\"1749440815642\" duration=\"944000\" />\r\n      <workItem from=\"1749477216999\" duration=\"3379000\" />\r\n      <workItem from=\"1749482049538\" duration=\"9729000\" />\r\n      <workItem from=\"1749562433952\" duration=\"5281000\" />\r\n      <workItem from=\"1749602364179\" duration=\"8042000\" />\r\n      <workItem from=\"1749611863579\" duration=\"6407000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Update AlphaBetaGhost + MinimaxGhost\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1749492063024</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1749492063024</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Update AlphaBetaGhost + MinimaxGhost\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1749608704018</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1749608704018</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"&#10;.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1749608742908</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1749608742908</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"4\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Update AlphaBetaGhost + MinimaxGhost\" />\r\n    <MESSAGE value=\"&#10;.\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"&#10;.\" />\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$pacman.coverage\" NAME=\"pacman Coverage Results\" MODIFIED=\"1749025953891\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent\" />\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$layout.coverage\" NAME=\"layout Coverage Results\" MODIFIED=\"1749025975768\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent\" />\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$projectParams.coverage\" NAME=\"projectParams Coverage Results\" MODIFIED=\"1749025972087\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent\" />\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$multiAgents.coverage\" NAME=\"multiAgents Coverage Results\" MODIFIED=\"1749291694546\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent\" />\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$game.coverage\" NAME=\"game Coverage Results\" MODIFIED=\"1749291698440\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent\" />\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$tm.coverage\" NAME=\"tạm Coverage Results\" MODIFIED=\"1749025948224\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent\" />\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$testClasses.coverage\" NAME=\"testClasses Coverage Results\" MODIFIED=\"1749291686366\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent\" />\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$main.coverage\" NAME=\"main Coverage Results\" MODIFIED=\"1749291679993\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent/A_search\" />\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$pacmanAgents.coverage\" NAME=\"pacmanAgents Coverage Results\" MODIFIED=\"1749291690910\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent\" />\r\n    <SUITE FILE_PATH=\"coverage/AI_Pacman$keyboardAgents.coverage\" NAME=\"keyboardAgents Coverage Results\" MODIFIED=\"1749025979949\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/multiagent\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision c8b45e353c6238e835b605e70e8a249937c113f0)
+++ b/.idea/workspace.xml	(date 1749622949417)
@@ -5,7 +5,6 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="b14f4dbb-6c9e-4991-ad6e-6afb3026a58a" name="Changes" comment="&#10;.">
-      <change beforePath="$PROJECT_DIR$/.idea/AI_Pacman.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/AI_Pacman.iml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/multiagent/ghostAgents.py" beforeDir="false" afterPath="$PROJECT_DIR$/multiagent/ghostAgents.py" afterDir="false" />
     </list>
@@ -219,7 +218,7 @@
       <workItem from="1749482049538" duration="9729000" />
       <workItem from="1749562433952" duration="5281000" />
       <workItem from="1749602364179" duration="8042000" />
-      <workItem from="1749611863579" duration="6407000" />
+      <workItem from="1749611863579" duration="7640000" />
     </task>
     <task id="LOCAL-00001" summary="Update AlphaBetaGhost + MinimaxGhost">
       <option name="closed" value="true" />
